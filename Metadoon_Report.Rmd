---
title: "Metadoon Analysis Report"
output: html_document
fontsize: 11pt
geometry: margin=1in
---

```{r setup, include=FALSE}
# --- LOAD PACKAGES ---
library(phyloseq)
library(vegan)
library(ggplot2)
library(ggpubr)
library(cowplot)
library(dplyr)
library(DESeq2)
library(scater)
library(rprojroot)
library(pairwiseAdonis)
library(pheatmap)
library(viridis)
library(ape)
library(microbiome)
library(wesanderson)
library(RColorBrewer)
library(jsonlite)
library(ggrepel)

# --- GLOBAL KNITR OPTIONS ---
knitr::opts_chunk$set(
  echo = FALSE, 
  message = FALSE, 
  warning = FALSE, 
  fig.keep = 'all', 
  fig.align = 'center',
  out.extra = 'style="margin-top:30px;"'
)

# --- HELPER FUNCTIONS ---
`%||%` <- function(a, b) if (!is.null(a)) a else b

# --- DIRECTORY SETUP ---
# Tenta localizar a raiz. Se falhar, usa o diretÃ³rio atual.
script_dir <- tryCatch(find_root(has_file("Analise.R")), error = function(e) getwd())
output_dir <- file.path(script_dir, "Output")
if (!dir.exists(output_dir)) dir.create(output_dir)

# --- LOAD PARAMETERS ---
params_file <- file.path(script_dir, "pipeline_params.json")
if (file.exists(params_file)) {
  params <- fromJSON(params_file)
} else {
  params <- list()
}

# --- PARAMETER ASSIGNMENT ---
stat_test <- params$stat_test %||% "anova"
dist_method <- params$dist_method %||% "bray"
color_palette <- params$color_palette %||% "viridis"
abundance_top_n <- params$abundance_top_n %||% 15
core_top_n <- params$core_top_n %||% 30
rarefaction_step <- params$rarefaction_step %||% 100
rarefaction_cex <- params$rarefaction_cex %||% 0.6
rarefaction_label <- params$rarefaction_label %||% FALSE
enable_rarefaction <- params$enable_rarefaction %||% FALSE
rarefaction_depth <- params$rarefaction_depth %||% 1000

# --- PALETTES ---
get_palette <- function(palette_name) {
  switch(palette_name,
         viridis = viridis::viridis(10),
         plasma = viridis::plasma(10),
         inferno = viridis::inferno(10),
         magma = viridis::magma(10),
         cividis = viridis::cividis(10),
         wesanderson = wesanderson::wes_palette("Darjeeling1", 5, type = "discrete"),
         RColorBrewer::brewer.pal(10, "Set3")
  )
}
palette_base <- get_palette(color_palette)

get_dynamic_palette <- function(base_palette, n_colors) {
  if (n_colors > length(base_palette)) {
    return(colorRampPalette(base_palette)(n_colors))
  } else {
    return(base_palette[1:n_colors])
  }
}
# --- FILE PATHS ---
otu_file <- file.path(script_dir, "OTUs/otutab.txt")
taxonomy_file <- file.path(script_dir, "Taxonomy/taxonomy.txt")
metadata_dir <- file.path(script_dir, "Metadata File")
tree_file_path <- file.path(script_dir, "Tree File/tree.nwk")

# --- CHECK FILES ---
if (!file.exists(otu_file)) stop(paste("OTU file not found:", otu_file))
if (!file.exists(taxonomy_file)) stop(paste("Taxonomy file not found:", taxonomy_file))

# --- LOAD TABLES ---
# comment.char="" is CRITICAL for VSEARCH headers starting with #
otu_mat <- as.matrix(read.table(otu_file, header = TRUE, sep = "\t", row.names = 1, check.names = FALSE, comment.char = ""))
tax_mat <- as.matrix(read.table(taxonomy_file, header = TRUE, sep = "\t", row.names = 1, check.names = FALSE, fill = TRUE, comment.char = ""))

# --- SYNC IDS ---
common_taxa <- intersect(rownames(otu_mat), rownames(tax_mat))

if(length(common_taxa) == 0) {
  stop("CRITICAL ERROR: No common OTUs found between OTU Table and Taxonomy.")
}

otu_mat_clean <- otu_mat[common_taxa, ]
tax_mat_clean <- tax_mat[common_taxa, ]

# --- LOAD METADATA ---
metadata_files <- list.files(path = metadata_dir, pattern = "\\.tsv$|\\.csv$", full.names = TRUE)
if (length(metadata_files) > 0) {
  sep <- ifelse(grepl("\\.tsv$", metadata_files[1]), "\t", ",")
  metadataTab <- read.csv(metadata_files[1], header = TRUE, row.names = 1, sep = sep, check.names = FALSE)
  
  # Sync Samples
  common_samples <- intersect(colnames(otu_mat_clean), rownames(metadataTab))
  if(length(common_samples) > 0){
    otu_mat_clean <- otu_mat_clean[, common_samples]
    metadataTab_clean <- metadataTab[common_samples, , drop=FALSE]
  } else {
    stop("Error: No common samples between OTU table and Metadata.")
  }
} else {
  stop("Metadata file not found.")
}

# --- LOAD TREE ---
if (file.exists(tree_file_path)) {
  Arv <- tryCatch(read.tree(tree_file_path), error=function(e) NULL)
} else {
  Arv <- NULL
}

# --- CREATE PHYLOSEQ OBJECT ---
if (is.null(Arv)) {
  ps <- phyloseq(
    otu_table(otu_mat_clean, taxa_are_rows = TRUE),
    tax_table(tax_mat_clean),
    sample_data(metadataTab_clean)
  )
} else {
  ps <- phyloseq(
    otu_table(otu_mat_clean, taxa_are_rows = TRUE),
    tax_table(tax_mat_clean),
    sample_data(metadataTab_clean),
    phy_tree(Arv)
  )
}

# --- SAFETY CHECK ---
if(!exists("ps")) stop("CRITICAL: Phyloseq object 'ps' was not created.")
print(ps)
```

### Rarefaction Curve

The rarefaction curve provides insight into the richness of microbial communities across samples. It estimates the number of observed species (or OTUs) as a function of the sequencing depth. A plateau indicates sufficient sampling depth.
A rarefaction curve graphically represents the expected number of observed species (or operational taxonomic units, OTUs) in microbial communities as sequencing depth increases through repeated random subsampling of reads. This standardization allows fair comparisons of species richness across samples with unequal sequencing efforts, mitigating biases from varying library sizes.


## Applications in Microbiome Analysis

Rarefaction assesses sampling completeness and alpha diversity (richness and evenness within samples), essential for metagenomic studies like 16S rRNA or shotgun sequencing. Despite debates on its limitations for rare species extrapolation, it remains a robust normalization method for uneven data.

```{r rarefact_data, include=TRUE, echo= FALSE}
# Extract OTU table as matrix
otu <- as(otu_table(ps), "matrix")
if (!taxa_are_rows(ps)) {
  otu <- t(otu)
} else {
  otu <- t(otu) # Rarecurve expects samples as rows
}

# Plot rarefaction curve
vegan::rarecurve(otu, step = rarefaction_step, cex = rarefaction_cex, label = rarefaction_label)
title("Rarefaction Curve")

# Apply Rarefaction if enabled
rarefy_phyloseq <- function(ps, depth = rarefaction_depth) {
  if (enable_rarefaction) {
    min_reads <- min(sample_sums(ps))
    if (depth > min_reads) {
      depth <- min_reads
    }
    ps_rarefied <- rarefy_even_depth(ps, sample.size = depth, replace = TRUE, verbose = FALSE)
    return(ps_rarefied)
  } else {
    return(ps)
  }
}
# Update ps object for downstream analysis
ps <- rarefy_phyloseq(ps)
```

Interpretation: - Samples that plateau have been sequenced to near saturation. - Curves that rise sharply with no sign of plateau suggest under-sampling.

### Relative abundance:

Relative abundance analysis illustrates the proportional representation of microbial taxa within each sample, typically aggregated at different taxonomic levels (e.g., Phylum, Genus). These stacked bar plots help visualize shifts in the dominant microbial community composition across experimental groups or conditions.

```{r relative_abundance, include=TRUE, echo= FALSE}
save_plot <- function(plot, filename, width = 12, height = 8) {
  ggsave(filename = file.path(output_dir, filename), plot = plot, width = width, height = height, dpi = 300, bg = "white")
}

plot_abundance <- function(ps, taxrank, top_n = abundance_top_n) {
  ps_tax <- tax_glom(ps, taxrank = taxrank)
  ps_rel <- transform_sample_counts(ps_tax, function(x) x / sum(x))
  taxa_sums <- taxa_sums(ps_rel)
  top_taxa <- names(sort(taxa_sums, decreasing = TRUE)[1:top_n])
  tax_table(ps_rel)[!(taxa_names(ps_rel) %in% top_taxa), taxrank] <- "Others"
  
  n_colors_needed <- length(unique(psmelt(ps_rel)[[taxrank]]))
  pal <- get_dynamic_palette(palette_base, n_colors_needed)

  p <- ggplot(psmelt(ps_rel), aes(x = Sample, y = Abundance, fill = !!sym(taxrank))) +
    geom_bar(stat = "identity") +
    labs(title = paste("Relative Abundance by", taxrank), x = "Sample", y = "Relative Abundance") +
    theme_minimal(base_size = 14) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    scale_fill_manual(values = pal)
  save_plot(p, paste0("abundance_", taxrank, ".png"), width = 16, height = 10)
  print(p)
}

for (rank in c("Phylum", "Class", "Order", "Family", "Genus")) {
  plot_abundance(ps, rank)
}
```
- Each bar represents the composition of one sample, with colors indicating the relative proportions of taxa.

- Taxa with higher proportions (larger segments) dominate the microbial community.

- Group-wise comparisons allow identification of patterns or shifts in community structure (e.g., enrichment or depletion of specific taxa).

- The "Others" category groups less abundant taxa to reduce noise and improve clarity.

### Core-Microbiome:

The core microbiome refers to the set of microbial taxa that are consistently detected across a defined proportion of samples within a group. Identifying core taxa is essential for understanding the stable and potentially functionally important members of the microbial community. In the heatmaps below, prevalence (frequency of detection) and detection thresholds (minimum relative abundance) are used to determine which taxa are considered part of the core microbiome.

```{r core_microbiome, include=TRUE, echo=FALSE, out.extra='style="margin-top:60px;"', out.width="100%"}
# Updated parameters for better detection
prevalences <- seq(0.05, 1, 0.05)
detections <- c(0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)

plot_core_heatmap <- function(ps, taxrank, top_n = core_top_n) {
  
  tryCatch({
    ps_tax <- tax_glom(ps, taxrank)
    ps_tax_rel <- transform_sample_counts(ps_tax, function(x) x / sum(x))
    
    prev_table <- microbiome::prevalence(ps_tax_rel)
    if(length(prev_table) == 0) return(NULL)

    top_taxa <- names(sort(prev_table, decreasing = TRUE)[1:min(length(prev_table), top_n)])
    ps_top_taxa <- prune_taxa(top_taxa, ps_tax_rel)
    
    # Replace OTU IDs with Taxa Names
    tax_mat <- as(tax_table(ps_top_taxa), "matrix")
    tax_names <- tax_mat[, taxrank]
    tax_names[is.na(tax_names)] <- taxa_names(ps_top_taxa)[is.na(tax_names)]
    taxa_names(ps_top_taxa) <- tax_names
    
    n_colors_needed <- length(taxa_names(ps_top_taxa)) 
    pal <- get_dynamic_palette(palette_base, n_colors_needed) 
    
    p <- plot_core(ps_top_taxa,
                   plot.type = "heatmap",
                   prevalences = prevalences,
                   detections = detections,
                   min.prevalence = 0.2) + # Ajustado
      xlab("Detection Threshold (Relative Abundance)") +
      ylab(taxrank) +
      scale_fill_gradientn(colours = pal) +
      theme_minimal() +
      ggtitle(paste("Core Microbiome at", taxrank, "Level")) +
      scale_x_discrete(breaks = as.character(detections))
      
    save_plot(p, paste0("core_microbiome_heatmap_", taxrank, ".png"), width = 16, height = 10)
    print(p)
    
  }, error = function(e) {
    cat(paste("Skipping Core Heatmap for", taxrank, ": Insufficient data."))
  })
}

for (rank in c("Phylum", "Class", "Order", "Family", "Genus")) {
  plot_core_heatmap(ps, rank)
}
```
- Rows represent taxa and columns represent detection thresholds.

- Colors indicate the proportion of samples in which the taxon is detected at or above the threshold.

- Taxa with high prevalence across multiple thresholds are strong candidates for being part of the core microbiome.

- Patterns can be compared across taxonomic levels (e.g., Phylum vs. Genus) for broader or finer biological insights.

### Alpha Diversity:
Alpha diversity metrics quantify the diversity within a single microbial community (sample). They describe both richness (number of taxa) and evenness (how uniformly the taxa are distributed). Commonly used indices include Observed, Chao1, ACE (richness estimators), Shannon (balance between richness and evenness), and Simpson (probability that two individuals randomly selected belong to the same species).

```{r alpha_diversity, include=TRUE, echo= FALSE, out.width="49%", fig.show='hold'}
plot_alpha_diversity <- function(ps) {
  
  if (!dir.exists("Output")) dir.create("Output")
  
  alpha_div <- estimate_richness(ps, measures = c("Shannon", "Simpson", "Chao1", "ACE", "Observed"))
  alpha_div$SampleID <- rownames(alpha_div)
  
  meta_data <- as(sample_data(ps), "data.frame")
  meta_data$SampleID <- rownames(meta_data)
  
  alpha_merged <- merge(alpha_div, meta_data, by = "SampleID")
  
  indices <- c("Observed", "Chao1", "ACE", "Shannon", "Simpson")
  meta_columns <- setdiff(colnames(meta_data), "SampleID")
  if (length(meta_columns) == 0) stop("No metadata columns found besides SampleID.")
  
  clean_test <- tolower(stat_test)
  if (clean_test %in% c("t-test", "ttest")) clean_test <- "t.test"
  if (clean_test %in% c("wilcox")) clean_test <- "wilcox.test"
  if (clean_test %in% c("kruskal")) clean_test <- "kruskal.test"
  if (clean_test %in% c("anova")) clean_test <- "anova"
  
  method_for_title <- ifelse(clean_test %in% c("t.test", "anova"), "anova", "kruskal.test")
  
  for (meta_var in meta_columns) {
    if (length(unique(meta_data[[meta_var]])) < 2) next
    
    pal <- get_dynamic_palette(palette_base, length(unique(meta_data[[meta_var]])))
    
    cat(paste0("\n### Grouped by: ", meta_var, "\n"))
    
    for (index in indices) {
      plot_df <- data.frame(
        Sample = alpha_merged$SampleID,
        Diversity = alpha_merged[[index]],
        Group = as.factor(alpha_merged[[meta_var]])
      )
      
      p_label <- ""
      tryCatch({
        stat_res <- compare_means(Diversity ~ Group, data = plot_df, method = method_for_title)
        p_label <- paste0("(p = ", stat_res$p.format, ")")
      }, error = function(e) { p_label <<- "(p = NA)" })
      
      p <- ggboxplot(plot_df, x = "Group", y = "Diversity", color = "Group", add = "jitter") +
        labs(title = paste("Alpha Diversity -", index, p_label),
             subtitle = paste("Grouped by:", meta_var),
             x = meta_var, y = index) +
        theme_minimal(base_size = 14) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_color_manual(values = pal)
      
      ggsave(filename = paste0("Output/alpha_diversity_", index, "_", meta_var, ".png"),
             plot = p, width = 8, height = 6, dpi = 600, bg = "white")
      
      print(p)
    }
  }
}

plot_alpha_diversity(ps)
```







- Observed: the raw count of taxa detected in each sample.

- Chao1: an estimator that infers the total richness by accounting for rare taxa.

- se.chao1: the standard error of the Chao1 estimate.

- ACE: another estimator of species richness using abundance-based coverage.

- se.ACE: the standard error associated with the ACE estimate.

- Shannon: considers both richness and evenness; higher values indicate more balanced and diverse communities.

- Simpson: emphasizes evenness and dominance; lower values reflect higher diversity (i.e., less dominance by few taxa).

-- These metrics are useful to compare how diverse microbial communities are across treatments or conditions. Large differences in alpha diversity may indicate ecological responses to environmental or experimental variables.
-- Use this analysis to pinpoint key taxa that respond to experimental treatments or environmental gradients.








### Beta Diversity:

Beta diversity evaluates the differences in microbial composition between samples or groups. It measures the extent to which communities share similar taxa and relative abundances. NMDS (Non-metric Multidimensional Scaling) is a common ordination method used to visualize beta diversity.

## NMDS
```{r beta_diversity_nmds, include=TRUE, echo= FALSE}
plot_nmds_diversity <- function(ps, dist_method = dist_method) {
  
  meta_data <- as(sample_data(ps), "data.frame")
  meta_data$SampleID <- rownames(meta_data)
  meta_columns <- setdiff(colnames(meta_data), "SampleID")
  dist <- phyloseq::distance(ps, method = dist_method)
  
  ord_nmds <- tryCatch(vegan::metaMDS(dist, k = 2, trymax = 100, trace = FALSE), error=function(e) NULL)
  
  if(is.null(ord_nmds)) return(NULL)

  nmds_df <- data.frame(ord_nmds$points)
  colnames(nmds_df) <- c("NMDS1", "NMDS2")
  nmds_df$SampleID <- rownames(nmds_df)
  stress_value <- ord_nmds$stress
  
  for (meta_var in meta_columns) {
    if (length(unique(meta_data[[meta_var]])) < 2) next
    
    pal <- get_dynamic_palette(palette_base, length(unique(meta_data[[meta_var]])))
    
    nmds_df$Group <- meta_data[match(nmds_df$SampleID, meta_data$SampleID), meta_var]
    
    # PERMANOVA
    p_value <- tryCatch({
      formula_permanova <- as.formula(paste("dist ~", meta_var))
      res <- vegan::adonis2(formula_permanova, data = meta_data, permutations = 999)
      signif(res$`Pr(>F)`[1], 3)
    }, error = function(e) "NA")
    
    p <- ggplot(nmds_df, aes(x = NMDS1, y = NMDS2, color = Group, label = SampleID)) +
      geom_point(size = 3) +
      geom_text(vjust = -0.8, hjust = 0.5, size = 3) + 
      stat_ellipse(level = 0.95, show.legend = FALSE) +
      labs(title = paste("Beta Diversity - NMDS grouped by", meta_var),
           subtitle = paste("Stress:", signif(stress_value, 3), 
                            "| PERMANOVA p =", p_value),
           x = "NMDS1", y = "NMDS2") +
      theme_minimal(base_size = 14) +
      scale_color_manual(values = pal)
    
    ggsave(filename = paste0("Output/beta_diversity_NMDS_", meta_var, ".png"),
           plot = p, width = 10, height = 8, dpi = 600, bg = "white")
    
    print(p)
  }
}

plot_nmds_diversity(ps, dist_method)
```
## PCoA
```{r beta_diversity_pcoa, include=TRUE, echo= FALSE}
plot_pcoa_diversity <- function(ps, dist_method = dist_method) {
  
  meta_data <- as(sample_data(ps), "data.frame")
  meta_data$SampleID <- rownames(meta_data)
  meta_columns <- setdiff(colnames(meta_data), "SampleID")
  
  dist <- phyloseq::distance(ps, method = dist_method)
  ord_pcoa <- ape::pcoa(as.matrix(dist))
  pcoa_df <- data.frame(ord_pcoa$vectors[, 1:2])
  colnames(pcoa_df) <- c("PCoA1", "PCoA2")
  pcoa_df$SampleID <- rownames(pcoa_df)
  
  for (meta_var in meta_columns) {
    if (length(unique(meta_data[[meta_var]])) < 2) next
    
    pal <- get_dynamic_palette(palette_base, length(unique(meta_data[[meta_var]])))
    
    pcoa_df$Group <- meta_data[match(pcoa_df$SampleID, meta_data$SampleID), meta_var]
    
    p_value <- tryCatch({
      formula_permanova <- as.formula(paste("dist ~", meta_var))
      res <- vegan::adonis2(formula_permanova, data = meta_data, permutations = 999)
      signif(res$`Pr(>F)`[1], 3)
    }, error = function(e) "NA")
    
    p <- ggplot(pcoa_df, aes(x = PCoA1, y = PCoA2, color = Group, label = SampleID)) +
      geom_point(size = 3) +
      geom_text(vjust = -0.5, hjust = 0.5) +
      stat_ellipse() +
      labs(title = paste("Beta Diversity - PCoA grouped by", meta_var),
           subtitle = paste("PERMANOVA p =", p_value),
           x = "PCoA1", y = "PCoA2") +
      theme_minimal(base_size = 14) +
      scale_color_manual(values = pal)
    
    ggsave(filename = paste0("Output/beta_diversity_PCoA_", meta_var, ".png"),
           plot = p, width = 10, height = 8, dpi = 600, bg = "white")
    
    print(p)
  }
}

plot_pcoa_diversity(ps, dist_method)
```

Interpretation: - Each point represents a microbial community from a sample. - Samples closer together are more similar in composition. - Ellipses indicate clustering patterns by metadata group. - NMDS (Non-metric Multidimensional Scaling): focuses on rank-order distances; does not preserve exact distances but reveals relative similarities. Good for complex, non-linear relationships. - PCoA (Principal Coordinates Analysis): preserves actual distances as well as possible; useful when understanding variance structure of dissimilarity matrix.


### Permanova:
PERMANOVA is a non-parametric method used to test whether the centroids (i.e., average community compositions) of different groups differ significantly. It uses permutations on a distance matrix to assess whether the observed differences between groups are greater than expected by chance.
```{r permanova, include=TRUE, echo= FALSE}
run_permanova <- function(ps) {
  
  if (!dir.exists("Output")) dir.create("Output")
  
  meta_data <- as(sample_data(ps), "data.frame")
  dist_bc <- phyloseq::distance(ps, method = "bray")
  meta_columns <- colnames(meta_data)
  
  for (meta_var in meta_columns) {
    
    formula <- as.formula(paste("dist_bc ~", meta_var))
    permanova_result <- adonis2(formula, data = meta_data, permutations = 999)
    
    result_file <- paste0("Output/permanova_result_", meta_var, ".txt")
    
    write.table(permanova_result, file = result_file, sep = "\t", col.names = NA, quote = FALSE)
    
    message(paste0("PERMANOVA result saved for ", meta_var))
    print(permanova_result)
  }
}
run_permanova(ps)
```
Interpretation: - The pseudo-F statistic indicates the ratio of between-group to within-group variance. - A low p-value (< 0.05) suggests significant differences in community composition between groups. - PERMANOVA assumes similar dispersion among groups; pair this analysis with a check for homogeneity of dispersion (e.g., using betadisper).


### Deseq2:
DESeq2 identifies taxa that are differentially abundant between sample groups based on count data. It models the counts using a negative binomial distribution and performs statistical testing to identify significant log2 fold changes between conditions.
```{r DESeq2, include=TRUE, echo= FALSE}
run_deseq2 <- function(ps) {
  
  if (!dir.exists("Output")) dir.create("Output")
  
  meta_data <- as(sample_data(ps), "data.frame")
  meta_columns <- setdiff(colnames(meta_data), "SampleID")
  
  taxa_table <- as(tax_table(ps), "matrix")
  tax_labels <- apply(taxa_table, 1, function(x) paste(na.omit(x[1:6]), collapse="|"))
  
  gm_mean = function(x, na.rm=TRUE){ exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x)) }

  for (meta_var in meta_columns) {
    if (length(unique(meta_data[[meta_var]])) < 2) next
    
    cat(paste0("\n#### Analysis for: ", meta_var, "\n"))
    
    tryCatch({
      dds <- phyloseq_to_deseq2(ps, as.formula(paste("~", meta_var)))
      geoMeans = apply(counts(dds), 1, gm_mean)
      estimateSizeFactors(dds, geoMeans = geoMeans)
      dds <- DESeq(dds, test = "Wald", fitType = "parametric", quiet = TRUE)
      
      res <- results(dds, cooksCutoff = FALSE)
      res_sig <- subset(res, padj < 0.05)
      
      if (nrow(res_sig) > 0) {
        res_sig_df <- as.data.frame(res_sig)
        res_sig_df$Taxa <- rownames(res_sig_df)
        
        p <- ggplot(res_sig_df, aes(x = reorder(Taxa, log2FoldChange), y = log2FoldChange, fill = log2FoldChange > 0)) +
          geom_bar(stat = "identity") +
          coord_flip() +
          labs(title = paste("Differential Abundance (", meta_var, ")"), x = "Taxa", y = "Log2 Fold Change") +
          theme_minimal() +
          scale_fill_manual(values = c("red", "blue"), labels = c("Decrease", "Increase")) +
          theme(legend.title = element_blank())
        
        save_plot(p, paste0("deseq2_differential_taxa_", meta_var, ".png"))
        print(p)
      } else {
        cat("\n> No significant taxa found (padj < 0.05) for this variable.\n") 
      }
    }, error = function(e) {
      cat(paste("\n> Error running DESeq2 for", meta_var, ":", e$message, "\n"))
    })
  }
}
run_deseq2(ps)
```

```{r end, include=FALSE, echo= FALSE}
gc() 
message("Script executed successfully. All results have been saved in the 'Output' folder.")
```